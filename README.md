## sorting-algorithm

经常听到别人提排序算法，在这里做一个简单的归纳

### 简述

​	虽然说我是软工出身的，但是对于算法这一块比较薄弱，以前一直以为，前端工程师并不需要过多深入学习算法，在工作过程中，很快就知道这个观念是错误的，现在的我坚信一句话：学习某一个东西一定是会有帮助的，如果觉得这个东西对你帮助不大，那么可能说是你自身没有达到这个高度。

### 时间复杂度

有关时间复杂度的定义，可以在百度、google上查阅，这里只为留一个印象。

Ο(1) 表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是 Ο(1) 。其中 Ο($log_2n$) 、Ο(n) 、 Ο($nlog_2n$)、Ο($n^2$) 和 Ο($n^3$) 称为多项式时间，而 Ο($2^n$)  和 Ο(n!) 称为指数时间。

常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο($log_2n$)＜Ο(n)＜Ο($nlog_2n$)＜Ο($n^2$)＜Ο($n^3$)＜…＜Ο($2^n$)＜Ο(n!)

#### 经典算法对比

| 排序算法 |   平均时间复杂度    |     最好情况     |     最怀情况     |    空间复杂度     |   排序方式    | 稳定性  |
| :--: | :----------: | :----------: | :----------: | :----------: | :-------: | :--: |
| 冒泡排序 |   O($n^2$)   |     Ο(n)     |   O($n^2$)   |     Ο(1)     | In-place  |  稳定  |
| 选择排序 |   O($n^2$)   |   O($n^2$)   |   O($n^2$)   |     Ο(1)     | In-place  | 不稳定  |
| 插入排序 |   O($n^2$)   |     Ο(n)     |   O($n^2$)   |     Ο(1)     | In-place  |  稳定  |
| 希尔排序 | Ο($nlog_2n$) |     Ο(n)     |   O($n^2$)   |     Ο(1)     | In-place  | 不稳定  |
| 归并排序 | Ο($nlog_2n$) | Ο($nlog_2n$) | Ο($nlog_2n$) |     Ο(n)     | Out-place |  稳定  |
| 快速排序 | Ο($nlog_2n$) | Ο($nlog_2n$) |   O($n^2$)   | Ο($nlog_2n$) | In-place  | 不稳定  |
| 堆排序  | Ο($nlog_2n$) | Ο($nlog_2n$) | Ο($nlog_2n$) |     Ο(1)     | In-place  | 不稳定  |
| 计数排序 |   Ο(n + k)   |   Ο(n + k)   |   Ο(n + k)   |     Ο(k)     | Out-place |  稳定  |
| 桶排序  |   Ο(n + k)   |   Ο(n + k)   |   O($n^2$)   |   Ο(n + k)   | Out-place |  稳定  |
| 基数排序 |   Ο(n * k)   |   Ο(n * k)   |   Ο(n * k)   |   Ο(n + k)   | Out-place |  稳定  |

n：数据规模

k：‘桶’的个数

In-place：占用常数内存，不占用额外内存

out-place：占用额外内存

稳定性：排序



